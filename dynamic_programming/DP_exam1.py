# 1로 만ㅡㄹ기
# 풀이 시간 20분, 시간 제한 1초, 메모리 제한 128MB
"""
정수 X가 주어졌을 때, 연산 4개를 적절하게 사용하여 1로 만들기 연산을 사용하는 횟수의 최솟값을 출력하라.
1. 5로 나누어 떨어지면 /5
2. 3으로 나누어 떨어지면 /3
3. 2로 나누어 떨어지면 /2
4. 1로 빼기

시작 : 17:06
끝 : 17:16
"""

"""
내가 생각한 풀이 
1. if문으로 되는 대로 풀기 -> "최소" 개수를 찾는 것이므로 X
2. 1부터 큰 것 부터 곱해서 해결해보기

"""

count = 0
N = int(input())
now_n = 1

while N !=  now_n:
    mul5 = now_n*5
    mul3 = now_n*3
    mul2 = now_n*2
    if N > mul5 :
        #mul5(현재 수보다 *5)보다 N(목표)가 크다면 
        now_n = mul5
    elif N < mul2 :
        #mul2(현재 수 * 2)보다 작다면 곱하는 것으로 해결이 더이상 불가능
        #따라서 나머지는 +로 처리 후 종료
        while N != now_n : 
            now_n += 1
            count += 1
        break
    elif N > mul3 : 
        # mul5 > N > mul3 이년 걍 mul3 곱합
        now_n = mul3
    else : 
        #mul 3 > n > mul2
        now_n = mul2
    count+=1

"""
모범답안
"""
X = int(input())
d = [0] * 30001 #앞에서 계산한 결과를 호출하기 위한 저장 테이블

for i in range(2,X+1):
    #모든 값에 대해 경우의 수를 정리해놓음
    # 현재 수에서 1을 빼는 경우 ( 앞의 경우에서 -1 하는게 지금 자리이므로 +1로 넣음)
    d[i] = d[i-1]+1
    # 현재 수에서 2로 나누어 떨어지는 경우
    if i %2 == 0 :
        d[i] = min(d[i],d[i//2]+1)
    if i %3 == 0 :
        d[i] = min(d[i],d[i//3]+1)
    if i%5 == 0 :
        d[i] = min(d[i],d[i//5]+1)
    
print(d[X])
