### 탐색
- 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
- 탐색 알고리즘
    1. DFS
    2. BFS

### 데이터 표현

1. 그래프로 표현한다.
    - 그래프는 Node, Edge로 표현
    - 그래프를 코드로 표현하는 두 가지 방식
        1. 인접 행렬 (Adgacency Matrix) : 2차원 배열로 연결 관계를 표현하는 것
            - 모든 노드끼리의 관계를 표현한다.
            - 데이터의 양이 많다. ( 메모리 낭비 )
            - 찾을 때 빠르게 index로 접근하여 찾을 수 있다. ex) 1번 노드와 3번 노드의 연결 arr[1][3]
        2. 인접 리스트 (Adgacency List) : 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
            - 데이터의 양이 적다 ( 메모리 절약 )
            - 찾을 때, 속도가 느리다. ( 연결된 데이터를 하나씩 확인 )
             
2. 그래프 탐색이란, **하나의 Node를 시작으로 다수에 Node에 방문하는 것**을 말함
3. 두 노드가 Edge로 연결되어 있다면, **두 노드는 인접**하다.


## DFS
1. **깊이 우선 탐색**, 깊은 부분을 우선적으로 탐색하는 알고리즘
2. 동작 과정
    1. 탐색 시작 노드를 스택에 삽입 후, 방문 처리
    2. 스택의 최상단 노드에 **방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리**
    3. **방문하지 않은 인접 노드가 없다면, 최상단 노드를 꺼낸다.**
    4. 2,3의 반복 (스택이 빌 때까지)
3. **스택 자료구조**에 기초한다는 점에서 구현이 간단. (스택을 실제로 사용하지 않아도 된다. **재귀적으로 구현이 가능**함)

## BFS
1. **너비 우선 탐색**, 가까운 노드부터 탐색하는 알고리즘
    - DFS는 최대한 멀리 있는 노드를 우선 탐색
    - BFS는 그 반대,
2. 동작 과정
    1. 탐색 시작 노드를 큐에 삽입하고, 방문 처리
    2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중, **방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리**
    3. 2번을 더 이상 수행할 수 없을 때까지 반복
3. **큐 자료구조**를 이용하여 선입선출 구조로 작성하는 것이 정석
    -**인접한 노드를 반복적으로 큐**에 넣도록 작성하면, 자연스럽게 선입 선출이 가능해져, **가까운 노드부터 탐색**을 진행하게 된다.