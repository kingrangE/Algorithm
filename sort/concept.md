## 정렬
- 데이터를 특정한 기준에 따라 순서대로 나열하는 알고리즘
- 정렬 알고리즘은 **이진 탐색의 데이터 전처리** 과정이기도 하다.
- 적절하지 못한 정렬 알고리즘을 사용하면 비효율적으로 프로그램이 동작하며 시간이 많이 소요.
- 다루는 정렬 알고리즘
    1. 선택 정렬
    2. 삽입 정렬
    3. 퀵 정렬
    4. 계수 정렬
    


## 선택정렬
- IDEA : '데이터 **전체를 탐색**하며 **가장 작은 값**을 찾고 그것을 **맨 앞의 값과 바꾸자**'
- 가장 작은 것을 선택하여 앞으로 보내는 과정을 반복 수행하는 정렬 알고리즘
- 선택 정렬의 시간 복잡도
    - i = 0 : N번 시행, i = 1 : N-1번 시행, i = 2 : N - 2번 시행 ... , 이므로 등차수열의 합과 같다.
    - 따라서 근사치로 ${\frac{N(N+1)}{2}}$라고 할 수 있다.
    - 이것은 빅오 표기법에 의해 O(${N^2}$)와 같다.

```python
#선택 정렬 코드
import random
n = 10
arr = [i for i in range(n)]
random.shuffle(arr)

for i in range(n):
    min_idx = i
    #모든 데이터를 한 번씩 시도해야 하므로 n(리스트 길이)만큼 반복
    for j in range(i+1,n):
        #현재보다 앞의 인덱스는 정렬이 되어있는 인덱스이므로 제외하고 나머지 중 최소값을 찾음
        if arr[min_idx] > arr[j]:
            min_idx = j
    #최소 값이 들어있는 인덱스와 시작 지점 인덱스의 값을 서로 바꿈
    arr[i],arr[min_idx]=arr[min_idx],arr[i]
```

## 삽입 정렬
- IDEA : '데이터를 확인하며 각 데이터를 적절한 위치에 삽입하자'
- 필요할 때만 위치를 바꾸는 알고리즘으로, 거의 정렬되어 있는 데이터에 이용할 때, 훨씬 효율적인 알고리즘이다.
- 특정한 데이터가 적절한 위치에 들어가기 전, 그 앞은 이미 정렬되어 있다 가정
    - 여기서 적절한 위치가 데이터가 삽입되는 위치
- 시간 복잡도
    - 반복문 2개를 사용하기에 선택정렬과 같은 O(${N^2}$) 시간 복잡도를 가진다.
    - 허나, 거의 정렬되어 있는 상태일 때는 매우 빠르게 동작하기에 최선의 경우 O(${N}$)이다.
    - 따라서 거의 정렬된 상태의 리스트를 정렬해야 하는 문제라면 삽입 정렬이 가장 빠를 가능성이 높다.
```python
import random
n = 10
arr = [i for i in range(n)]
random.shuffle(arr)

for i in range(1,n):
    for j in range(i,0,-1):
        #현재 위치부터 앞으로 한 칸씩 줄이면서 비교하는 것
        #현재 위치보다 앞의 값이 크다면, 앞의 값과 자리를 교환 => 반복
        if arr[j] < arr[j-1] :
            arr[j],arr[j-1] = arr[j-1],arr[j]
        else : 
            #작지 않다면 종료하면 된다. 그 앞은 이미 정렬이 되어있음
            break
```

## 퀵 정렬
- 가장 많이 사용되는 정렬 알고리즘, 병합 정렬과 비슷하게 빠른 알고리즘
- 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
- IDEA : '기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸자'
    - 기준 데이터 : pivot
        - 큰 숫자와 작은 숫자를 교환하기 위한 기준 데이터
        - 이 피벗을 설정하여 리스트를 분할하는 방법에 따라 여러가지 퀵 정렬이 존재한다.
    - 호어 분할 방식   
        - 리스트에서 **첫 번째 데이터를 피벗**으로 정한다.
    - 작동 순서
        1. 피벗을 설정
        2. 왼쪽에서부터 피벗보다 큰 데이터, 오른쪽에서부터 피벗보다 작은 데이터 찾기
        3. 찾으면 둘이 교환
        4. 반복하다. 왼쪽에서 찾은 큰 데이터 값의 인덱스가 오른쪽에서 찾은 작은 데이터 값의 인덱스보다 커지면(뒤에 있으면) 작은 데이터와 피벗의 위치를 변경
        5. 피벗의 위치가 변경됨으로서, 리스트가 분할된다.
        6. 분할된 리스트 각각에 1~5과정 반복 ( 재귀적 )
        7. 분할된 리스트의 원소가 1개일때, 종료

- 퀵 정렬의 시간 복잡도 
    - O(${NlogN}$)
```python
import random
n = 10
arr = [i for i in range(n)]
random.shuffle(arr)

def quick_sort(arr,pivot,start,end):
    if start >= end : 
        return 
    pivot = start
    left = start+1
    right  = end
    while left <= right :
        while left <= end and array[left] <= array[pivot] :
            left += 1
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if left > right :
            #엇갈렸다면 작은 데이터와 피벗의 자리를 교체
            array[pivot],array[right] = array[right],array[pivot]
        else : 
            #엇갈리지 않았다면 두 값의 위치를 교체
            array[left],array[right] = array[right],array[left]
    quick_sort(arr,start,right-1)
    quick_sort(arr,right+1,end)

quick_sort(arr,0,len(array)-1)
```

## 계수 정렬
- 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠른 정렬 알고리즘
- IDEA : '숫자를 인덱스로 생각하여 나온 숫자의 개수를 세는 리스트를 만들자'
- 리스트를 새로 생성해야 하기에 데이터의 크기 범위가 제한적이고 정수로 표현될 때에만 사용가능하다.
    - 일반적으로 ${0 <  x < 1,000,000}$
- 또한, 가장 큰 데이터와 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
    - 메모리 낭비의 문제 때문
- 모든 데이터가 양의 정수인 상황에서 데이터의 개수 N, 데이터 중 최대값의 크기를 K
    - O(N+K)의 시간 복잡도를 가진다.
        - 데이터만 한정되어 있다면 효과적이며, 항상 빠르게 동작한다.
    - 기수정렬과 더불어 가장 빠르다고 볼 수 있다.

- 계수 정렬은 때에 따라 심각한 비효율성을 초래할 수 있다.
    - if) 데이터가 0, 999999만 존재한다면 두 개의 데이터를 정렬하기 위해 100만 크기의 리스트를 선언해야 한다.
        - 따라서 항상 이용할 수 있는 알고리즘은 아니다.
        - 그러나 동일한 값을 가지는 데이터가 여러 개 등장할 때는 적합하다.
    - 따라서 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 이용하는 것이 유리하다.

```python
import random
n = 10
arr = [i for i in range(n)]
random.shuffle(arr)

#숫자의 범위가 0~9로 제한적, 해당 개수를 담을 리스트를 생성
nums = [0 for _ in range(n)]
for value in (arr):
    nums[value] += 1

for index,value in enumerate(nums) :
    for j in range(value):
        print(index,end=' ')
```